# 知识回顾



## html

### 语义化

html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。在没有引入样式 CCS 样式的时候也能以一种可以分辨出来大致表示内容的文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

```
<article> 独立的区域
<aside>	侧边栏
<details> 可以展开收起的区域
<figcaption>与其相关联的图片的说明/标题
<figure> 图片
<footer>	
<header>
<main>
<mark> 突出的文本
<nav>
<section>  一节，一般来说会有包含一个标题。
<summary> like detail
<time> 时间
```





## css

- [一文梳理 CSS 必会知识点](https://juejin.cn/post/6854573212337078285)



### CSS引入

#### 有哪些引入方式？通过link和@import引入有什么区别？（* ）

- **CSS引入方式有4种** 内联、内嵌、外链、导入
- **外链 link** 除了可以加载css之外,还可以定义rss、rel等属性，没有兼容性问题，支持使用javascript改变样式
- **导入@import** 是css提供的，只能用于加载css，不支持通过javascript修改样式
- 页面被加载的时候，link会被同时加载，而@import则需等到页面加载完后再加载，可能出现无样式网页







### 盒模型

两种 宽度计算方式不同

默认content-box



#### 获取和设置盒模型的宽高

- 第一种：

dom.style.width/height

这种方法只能获取使用内联样式的元素的宽和高。

- 第二种：

dom.currentStyle.width/height

这种方法获取的是浏览器渲染以后的元素的宽和高，无论是用何种方式引入的css样式都可以，但只有IE浏览器支持这种写法。

- 第三种：

window.getComputedStyle(dom).width/height

这种方法获取的也是浏览器渲染以后的元素的宽和高，但这种写法兼容性更好一些。

- 第四种：

dom.getBoundingClientRect().width/height

这种方法经常使用的场所是，计算一个元素的绝对位置（相对于视窗左上角），它能拿到元素的left、top、width、height 4个属性。



#### border颜色

没设置时取color的



#### 去除inline-block元素间间距的N种方法

1. 元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就木有了。考虑到代码可读性，显然连成一行的写法是不可取的，我们可以：

```html
<div class="space">
    <a href="##">
    惆怅</a><a href="##">
    淡定</a><a href="##">
    热血</a>
</div>
```

或者是：

```html
<div class="space">
    <a href="##">惆怅</a
    ><a href="##">淡定</a
    ><a href="##">热血</a>
</div>
```

或者是借助HTML注释：

```html
<div class="space">
    <a href="##">惆怅</a><!--
    --><a href="##">淡定</a><!--
    --><a href="##">热血</a>
</div>
```

2. 使用margin负值

   margin负值的大小与上下文的字体和文字大小相关，其中，间距对应大小值可以参见我之前“基于display:inline-block的列表布局”一文part 6的统计表格：
   ![图片](https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq6Jcrf1F9amot5V85cLUcmhdSjN0CUZSRQ8epOPezvhCYpmf7AjPSZ6zqibY0N0c2ibdVT74BsV5seA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   例如，对于12像素大小的上下文，Arial字体的`margin`负值为`-3`像素，Tahoma和Verdana就是`-4`像素，而Geneva为`-6`像素。

   由于外部环境的不确定性，以及最后一个元素多出的父margin值等问题，这个方法不适合大规模使用。

   

3. 不写结尾标签

   有兼容性

   ```html
   <div class="space">
       <a href="##">惆怅
       <a href="##">淡定
       <a href="##">热血
   </div>
   ```

   

4. 父元素使用font-size:0

   chrome现已取消最小12px的限制

   

5. letter-spacing、word-spacing

6. flex等改变盒布局方式



#### 行内元素可以设置padding，margin吗？

宽高不起作用

padding左右可以，上下不占实际位置，但是类似于定位，上下也有多出来



#### padding 百分比

根据**父元素**的**宽度**计算

是父元素，不是自己



为什么不根据自己的宽度呢？而要根据父元素？

1. 如果自己没宽度怎么算
2. 算了自己的，自己不又变大了，死循环





### 选择器

1. *匹配所有

   不建议直接使用，影响性能，每个元素都会带上。

   看了reset.css，是用具体标签做初始化的。

2. #id

   不常用，一般都是用class，id用来js获取元素

3. .class

4. li a

   后代选择器，不建议层级过多

5. 单个元素选择器

6. X:visited and X:link

   ```css
   a:link { color: red; }
   a:visted { color: purple; }
   ```

   我们使用`:link`伪类来定义所有还没点击的链接。

   另外还有`:visited`伪类可以让我们给*曾经*点击过或者*访问过*的链接添加样式。

7. x + y

   后面的第一个元素

8. x > y

   直接的子代

9. x ~ y

   后面的元素

10. X[title]、 X[href="foo"]

    属性选择器，

11. X:checked

12. X:after

13. X:hover

14. X:not(selector)

    过滤某个

15. X:nth-child(n)

    从1开始

16. X:nth-last-child(n)



### 优先级

| 选择器               | 权重值 |
| :------------------- | :----- |
| !important标识       | 10000  |
| 行内样式             | 1000   |
| id选择器             | 100    |
| 类、伪类、属性选择器 | 10     |
| 标签选择器           | 1      |
| 通配符 *             | 0      |



问题：已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。

>  <img src="1.jpg" style="width:480px!important;">  

期初看到这段代码一下子就想到这都 `!important` 了还有办法限制它的宽度？真的是被无知限制了想象力。

这里提供几种方法实现修改宽度：



1、使用max-width

虽然使用了 `important` ，但是也只是添加到了 `width` 属性上面，并不影响 max-width 。所以这里设置了 max-width 即可生效。

```javascript
img {
  max-width: 300px;
}
```

2、使用 transform:scale

```javascript
img {
  transform: scaleX(0.625);
}
```

3、使用 zoom

这个和CSS3的缩放是一样的效果

```javascript
img {
  zoom: 0.625：
}
```

4、使用 js

这个和CSS3的缩放是一样的效果

```javascript
document.getElementsByTagName("img")[0].setAttribute("style","width:300px!important;")
```

5、使用弹性盒模型

这个和CSS3的缩放是一样的效果

```javascript
img {
  box-sizing: border-box;
  padding: 0 90px;
}
```

6、使用animation

```javascript
img {
  animation: width 0s forwards;
}
@keyframes width {
  from {
    width: 300px;
  }
  to {
    width: 300px;
  }
}
```





### flex

#### flex-direction

方向 row column



#### flex-wrap

换行方式 倒着换行等



`flex-direction` 和 `flex-wrap` 可以简写成 **`flex-flow`** 。 `flex-flow` 使用时可以只显式设置一个值，也可以显式设置两个值：

- `flex-flow` 只显式设置一个值，并且该值和 `<flex-direction>` 相匹配时， `flex-wrap` 会取值 `initial`
- `flex-flow` 只显式设置一个值，并且该值和 `<flex-wrap>`相匹配时， `flex-direction` 会取值 `initial`
- `flex-flow` 显式设置两个值时， `flex-direction` 和 `flow-wrap` 没有先后顺序之分，即可 `flex-flow: column wrap` 和 `flex-flow: wrap column` 等同



#### justify-content

主轴方向的对齐方式

![img](E:\codee\VuePress-blog\docs\webArchitect\images\ad858777d27a4e34ae5c3bda0f88fe63~tplv-k3u1fbpfcp-watermark.awebp)

`space-between` 会让第一个Flex项目的盒子起始边缘与Flex容器主轴起点相稳合，最后一个Flex项目的盒子结束边缘与Flex容器主轴终点相稳合，其它相邻Flex项目之间间距相等。当Flex容器中只有一个Flex项目时，其表现行为和 `flex-start` 等同

`space-around` 会让第一个Flex项目的盒子起始边缘与Flex容器主轴起点间距和最后一个Flex项目的盒子结束边缘与Flex容器主轴终点间距相等，并且等于其他相邻两个Flex项目之间间距的一半。当Flex容器中只有一个Flex项目时，其表现行为和 `center` 等同

`space-evenly` 会让第一个Flex项目的盒子起始边缘与Flex容器主轴起点间距和最后一个Flex项目的盒子结束边缘与Flex容器主轴终点间距相等，并且等于其他相邻两个Flex项目之间间距。当Flex容器中只有一个Flex项目时，其表现行为和 `center` 等同



#### align-items

侧轴方向对齐

![img](E:\codee\VuePress-blog\docs\webArchitect\images\191245d917d2496baefa79f9a471039d~tplv-k3u1fbpfcp-watermark.awebp)



### grid

比flex强大很多

网格系统



#### 基础用法

```html
<div class="wrapper">
  <div class="one item">One</div>
  <div class="two item">Two</div>
  <div class="three item">Three</div>
  <div class="four item">Four</div>
  <div class="five item">Five</div>
  <div class="six item">Six</div>
</div>
```



```css
.wrapper {
  margin: 60px;
  /* 声明一个容器 */
  display: grid;
  /*  声明列的宽度  */
  grid-template-columns: repeat(3, 200px);
  /*  声明行间距和列间距  */
  grid-gap: 20px 50px;
  /*  声明行的高度  */
  grid-template-rows: 100px 200px;
}
.one {
  background: #19CAAD;
}
.two { 
  background: #8CC7B5;
}
.three {
  background: #D1BA74;
}
.four {
  background: #BEE7E9;
}
.five {
  background: #E6CEAC;
}
.six {
  background: #ECAD9E;
}
.item {
  text-align: center;
  font-size: 200%;
  color: #fff;
}
```



![img](E:\codee\VuePress-blog\docs\webArchitect\images\173895918bfd94e9~tplv-t2oaga2asx-watermark.awebp)

通过`grid-template-columns` 和 `grid-template-rows`来控制行和列





#### **fr 关键字**

`Grid` 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。`fr` 单位代表网格容器中可用空间的一等份。`grid-template-columns: 200px 1fr 2fr` 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。代码以及效果如下图所示：

```
.wrapper-3 {
  display: grid;
  grid-template-columns: 200px 1fr 2fr;
  grid-gap: 5px;
  grid-auto-rows: 50px;
}
```



![image](E:\codee\VuePress-blog\docs\webArchitect\images\17389591ccc256d1~tplv-t2oaga2asx-watermark.awebp)



#### **minmax() 函数**

我们有时候想给网格元素一个最小和最大的尺寸

`grid-template-columns: 1fr 1fr minmax(300px, 2fr)` 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍



#### 位置处理

justify-items 、align-items

```
start | end | center | stretch;
```



看起来是改变内部元素（文字等）的左中右。而不是该元素的位置



justify-content 、align-content

```
start | end | center | stretch | space-around | space-between | space-evenly;
```

这就跟flex的差不多，只是名字有点区别





#### 兼容性

![img](E:\codee\VuePress-blog\docs\webArchitect\images\17389592fa541366~tplv-t2oaga2asx-watermark.awebp)

兼容不太好，用的也不多

适合瀑布流的布局



### 1px border

1、用图片、不方便

2、动态改变viewport的缩放比例

```
	
<meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">

```

3、伪类 + transform

原理是把原先元素的 border 去掉，然后利用 `:before` 或者 `:after` 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位

- 单条 border

```css
.hairlines li{
    position: relative;
    border:none;
}
.hairlines li:after{
    content: '';
    position: absolute;
    left: 0;
    background: #000;
    width: 100%;
    height: 1px;
    -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
    -webkit-transform-origin: 0 0;
            transform-origin: 0 0;
}

```

- 四条 border

```css
.hairlines li{
    position: relative;
    margin-bottom: 20px;
    border:none;
}
.hairlines li:after{
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid #000;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    width: 200%;
    height: 200%;
    -webkit-transform: scale(0.5);
    transform: scale(0.5);
    -webkit-transform-origin: left top;
    transform-origin: left top;
}
```

样式使用的时候，也要结合 JS 代码，判断是否 Retina 屏

```js
if(window.devicePixelRatio && devicePixelRatio >= 2){
    document.querySelector('ul').className = 'hairlines';
}
```

可以支持圆角，唯一的一点小缺陷是 ` 用不了。







改viewport会影响整个页面，老项目还是得用伪类解决。





## js



### 数据类型

#### 类型分类

分两大类，共八种类型。

基本类型： Number、String、Null、Undefined、Boolean、Symbol、BigInt

引用类型： Object



#### 基本类型、引用类型区别

- 基本类型
  1. 存放在栈内存
  2. 数据的比较是值的比较
- 引用类型
  1. 栈内存存放指向堆内存中的地址。真实数据存储在堆内存中
  2. 数据的比较是引用地址的比较



#### undefined与null的区别

**是否相等**

```js
null == undefined   true
null === undefined  false
```

undefined值是派生自null值

与JavaScript的历史有关。1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示"无"的值。
根据C语言的传统，null被设计成可以自动转为0。

```
Number(null)0
Number(undefined)NaN
```

但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。
首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示"无"的值最好不是对象。
其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。
因此，Brendan Eich又设计了一个undefined。



**用法**

null表示"没有对象"，即该处不应该有值。典型用法是：

（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。

undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：

（1）变量被声明了，但没有赋值时，就等于undefined。

（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

（3）对象没有赋值的属性，该属性的值为undefined。

（4）函数没有返回值时，默认返回undefined。



#### symbol有什么用

1. 做唯一不重复的键值

2. 不用new，不是构造函数。像函数一样调用

3. 做私有属性。不会被`for in`、`Object.keys`、`JSON.stringify`之类的获取到。

   只能通过`Object.getOwnPropertySymbols`获取



#### BigInt

JS中，按照[IEEE 754-2008](https://link.segmentfault.com/?enc=QC1p6JNViWax%2FcbIhHoO8g%3D%3D.GhLuybeOKy%2BdMNDXHyRYIYXEfJUMdNJ0MupiDrnCGlLpiW6VtZHK3FIS%2BjBUosI30FI83x1ajQze0F2RvDDkXA%3D%3D)标准的定义，所有数字都以[双精度64位浮点](https://link.segmentfault.com/?enc=C2nXxdz5Qo6ZiLkR47AyOA%3D%3D.I%2BUAEefgZOCqdLiV1LzUXSUXpsj4riMZ%2BZcPqU2wsUOXYZGGMLoX7KQhwfzamwyctIMkqoisw68TnDxb8fBXmeWbY28VdPHKRzfF8XDJGck%3D)格式表示。

在此标准下，无法精确表示的非常大的整数将自动四舍五入。确切地说，JS 中的`Number`类型只能安全地表示`-9007199254740991 (-(2^53-1))` 和`9007199254740991(2^53-1)`之间的整数，任何超出此范围的整数值都可能失去精度。

```1c
console.log(9999999999999999);    // → 10000000000000000
```

该整数大于JS Number 类型所能表示的最大整数，因此，它被四舍五入的。意外四舍五入会损害程序的可靠性和安全性。这是另一个例子：

```abnf
// 注意最后一位的数字
9007199254740992 === 9007199254740993;    // → true
```

JS 提供`Number.MAX_SAFE_INTEGER`常量来表示 最大安全整数，`Number.MIN_SAFE_INTEGER`常量表示最小安全整数：

```javascript
const minInt = Number.MIN_SAFE_INTEGER;

console.log(minInt);         // → -9007199254740991

console.log(minInt - 5);     // → -9007199254740996

// notice how this outputs the same value as above
console.log(minInt - 4);     // → -9007199254740996
```



`BigInt`是一种新的数据类型，用于当整数值大于`Number`数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

重要的是要记住，不能使用`Number`和`BigInt`操作数的混合执行算术运算，需要通过显式转换其中的一种类型。 此外，出于兼容性原因，不允许在`BigInt`上使用一元加号（`+`）运算符。



详细：

https://segmentfault.com/a/1190000019912017



#### 没有BigInt之前怎么办

使用[JSBI](https://link.segmentfault.com/?enc=gH1STo%2FdvFDcCkyFmg6PbQ%3D%3D.RUwB0MWvYb1s3fNNuTKJOZhveeq5KymhWftBn2M6ldb7oHACnHbWtgsJJjDcGX7U)库，它是`BigInt`提案的纯JS实现。

这个库提供了一个与原生`BigInt`行为完全相同的API。下面是如何使用JSBI：

```javascript
import JSBI from './jsbi.mjs';

const b1 = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
const b2 = JSBI.BigInt('10');

const result = JSBI.add(b1, b2);

console.log(String(result));    // → '9007199254741001'
```

使用`JSBI`的一个优点是，一旦浏览器支持，就不需要重写代码。 相反，可以使用`babel`插件自动将JSBI代码编译为原生 `BigInt`代码。



**手写**

```js
let a = "9007199254740991";
let b = "1234567899999999999";

function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength , 0);//"0009007199254740991"
   b = b.padStart(maxLength , 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i=maxLength-1 ; i>=0 ; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t/10);
      sum = t%10 + sum;
   }
   if(f == 1){
      sum = "1" + sum;
   }
   return sum;
}
```



#### 创建对象方法对比

##### Obejct.create()

```
Object.create(null)
```

可以创建不含Object原型链的对象



```
Object.create({x:1})
```

如果传了对象，则是创建在原型链上，对象本身是个空对象









##### new Object()

传null也是继承了Object的原型链

如果传了对象，

```js
var c = {a:1}

var a = new Object(c)

a
{a: 1}
c
{a: 1}

a === c
true
```



只可以传一个参数











##### {}



 {}是javascript对象字面量创建的形式，其本质和new Object()并无区别，默认都是继承了Object对象上的prototype

















### 类型判断

#### typeof

可以判断基本类型，除了null

| Type                                                         | Result                                                       |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [Undefined](https://developer.mozilla.org/en-US/docs/Glossary/undefined) | `"undefined"`                                                |
| [Null](https://developer.mozilla.org/en-US/docs/Glossary/Null) | `"object"` (see [below](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null)) |
| [Boolean](https://developer.mozilla.org/en-US/docs/Glossary/Boolean) | `"boolean"`                                                  |
| [Number](https://developer.mozilla.org/en-US/docs/Glossary/Number) | `"number"`                                                   |
| [BigInt](https://developer.mozilla.org/en-US/docs/Glossary/BigInt) (new in ECMAScript 2020) | `"bigint"`                                                   |
| [String](https://developer.mozilla.org/en-US/docs/Glossary/String) | `"string"`                                                   |
| [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) (new in ECMAScript 2015) | `"symbol"`                                                   |
| [Function](https://developer.mozilla.org/en-US/docs/Glossary/Function) object (implements [[Call]] in ECMA-262 terms) | `"function"`                                                 |
| Any other object                                             | `"object"`                                                   |



##### typeof null是object

JS类型值是存在32 BIT 单元里,32位有1-3位表示TYPE TAG,其它位表示真实值
而表示object的标记位正好是低三位都是0
000: object. The data is a reference to an object.

而js 里的Null 是机器码NULL空指针, (0x00 is most platforms).所以空指针引用 加上 对象标记还是0,最终体现的类型还是object.

在ECMA6中, 曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了. 理由是历史遗留代码太多, 不想得罪人, 不如继续将错就错当和事老, 参考 [harmony:typeof_null [ES Wiki\]](https://link.zhihu.com/?target=http%3A//wiki.ecmascript.org/doku.php%3Fid%3Dharmony%3atypeof_null)



##### typeof function

function本质上也是一个对象，但是function对象与普通对象相比，其内部有一个[[Call]]方法，用来表示这个对象是可调用的，typeof操作符在判断Object时，如果内部实现了[[Call]]方法,就返回function。
附上typeof操作符返回判断图：



#### instanceof

`instanceof` 运算符用来检测 `constructor.prototype `是否存在于参数 `object` 的原型链上。

原型链是可以被修改的，所以这是不安全的判断方法。



##### 一些容易出错的点
```js
var simpleStr = "This is a simple string"; 
var myString  = new String();
var newStr    = new String("String created with constructor");
var myDate    = new Date();
var myObj     = {};
var myNonObj  = Object.create(null);

simpleStr instanceof String; // 返回 false, simpleStr并不是对象
myString  instanceof String; // 返回 true
newStr    instanceof String; // 返回 true
myString  instanceof Object; // 返回 true

myObj instanceof Object;    // 返回 true, 尽管原型没有定义
({})  instanceof Object;    // 返回 true, 同上
myNonObj instanceof Object; // 返回 false, 一种创建非 Object 实例的对象的方法

myString instanceof Date; // 返回 false

myDate instanceof Date;     // 返回 true
myDate instanceof Object;   // 返回 true
myDate instanceof String;   // 返回 false
```



##### 手写instanceof
核心: 原型链的向上查找。

```js
function myInstanceof (left, right) {
    // 基本数据类型直接返回false
    if (typeof left !== 'object' || left === null) return false
    // getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left)
    while (true) {
        // 查找到尽头，还没找到
        if (proto == null) return false
        // 找到相同的原型对象
        if (proto == right.prototype) return true
        proto = Object.getPrototypeOf(proto)
    }
}
```



#### Object.prototype.toString

`toString()` 方法返回一个表示该对象的字符串

如果此方法在自定义对象中未被覆盖，`toString()` 返回 "[object *type*]"，其中 `type` 是对象的类型



```
var toString = Object.prototype.toString;

toString.call(new Date); // [object Date]
toString.call(new String); // [object String]
toString.call(Math); // [object Math]

//Since JavaScript 1.8.5
toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]
```



**封装**

```js
var class2type = {};

// 生成class2type映射
"Boolean Number String Function Array Date RegExp Object Error".split(" ").map(function(item, index) {
    class2type["[object " + item + "]"] = item.toLowerCase();
})

function type(obj) {
    // 一箭双雕
    if (obj == null) {
        return obj + "";
    }
    return typeof obj === "object" || typeof obj === "function" ?
        class2type[Object.prototype.toString.call(obj)] || "object" :
        typeof obj;
}
```





#### Array.isArray

```
// 下面的函数调用都返回 true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
Array.isArray(new Array('a', 'b', 'c', 'd'))
// 鲜为人知的事实：其实 Array.prototype 也是一个数组。
Array.isArray(Array.prototype);
```

**Polyfill**

假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。

```
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```



#### 详细

- [JavaScript 专题之类型判断(上)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F28)
- [JavaScript 专题之类型判断(下)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F30)



### 类型转换

- [JavaScript 深入之头疼的类型转换(上)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F159)
- [JavaScript 深入之头疼的类型转换(下)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F164)



### this

#### 什么是`this`

1. this是JavaScript的关键字之一。它是 对象 自动生成的一个内部对象，只能在 对象 内部使用。随着函数使用场合的不同，this的值会发生变化。
2. **this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时**。（比较多人误解的地方）（它非常语义化，this在英文中的含义就是 **这，这个** ，但这其实起到了一定的误导作用，因为this并不是一成不变的，并不一定一直指向当前 **这个**）



#### `this` 绑定规则

1. 谁调用的就是谁，没给就是window
2. call、apply、bind主动改的
3. new



#### this绑定优先级

```haxe
new 绑定 > 显示绑定 > 隐式绑定 > 默认绑定
```





#### 总结

1. 如果函数被`new` 修饰

   ```haxe
      this绑定的是新创建的对象，例:var bar = new foo();  函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar , 这样的绑定方式叫 new绑定 .
   ```

2. 如果函数是使用`call,apply,bind`来调用的

   ```gradle
      this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj , 这样的绑定方式叫 显性绑定 .
   ```

3. 如果函数是在某个 上下文对象 下被调用

   ```kotlin
      this绑定的是那个上下文对象，例 : var obj = { foo : foo };    obj.foo();  foo 中的 this 就是 obj . 这样的绑定方式叫 隐性绑定 .
   ```

4. 如果都不是，即使用默认绑定

   ```nim
      例:function foo(){...} foo() ,foo 中的 this 就是 window.(严格模式下默认绑定到undefined).
      这样的绑定方式叫 默认绑定 .
   ```



#### 参考文档

https://segmentfault.com/a/1190000011194676



### 闭包

聊作用域。

返回函数引用了父级的变量，导致无法释放。

牵扯到垃圾回收机制。



### 作用域

作用域是指程序中定义变量的区域，该位置决定了变量的生命周期，也就是变量和函数的可访问范围。

JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。

函数的作用域是在函数调用的时候才决定的。



### 作用域链

当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this



当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。



函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！





### 变量提升

变量提升（Hoisting）可以将变量和函数在编译阶段放入内存，从而在执行阶段时在声明前使用



在声明变量 `a` 之前打印变量，控制台输出的结果是 `undefined`，而不是预期中的报错 `Uncaught ReferenceError: a is not defined`。这就是**变量提升**。



实际上，JS 并不会移动代码，变量提升和函数提升并不是真正意义上的“提升”，而是解释执行 JS 代码过程所带来的“特性”。



- 对于变量声明如 `var a = 3`，会为变量分配内存并初始化为 `undefined`，赋值语句在生成机器码阶段真正执行代码的时候才进行。
- 对于函数声明如 `function sayHello() { console.log('Hello there!') }`，会在内存里创建函数对象，并且直接初始化为该函数对象。



应当注意的是，函数声明的处理优先级要高于变量声明（意味着函数会“提升”到更靠前的位置），同名函数优先了



#### 匿名函数声明

基于变量声明和函数声明之间的区别，在实际应用中，使用**匿名函数**的方式执行声明更不容易产生奇怪的 Bug：

```
sayHi() // Uncaught TypeError: sayHi is not a functionconsole.log(sayHi) // undefinedvar sayHi = function() {    console.log('Hi there!')}sayHi() // Hi there!
```

使用匿名函数声明时，`sayHi` 声明发生变量提升，但赋值为 `undefined`，因此执行 `sayHi()` 时会报错 `Uncaught TypeError: sayHi is not a function`。随后执行完赋值语句后，才成为一个可以执行的函数变量。



#### 为什么要变量提升和函数提升

由于第一批 JS 虚拟机编译器上代码的设计失误，导致了变量在声明之前就被赋予了 `undefined` 的初始值，产生了变量提升



函数提升，为了解决相互引用





1. let 的「创建」过程被提升了，但是初始化没有提升。
2. var 的「创建」和「初始化」都被提升了。
3. function 的「创建」「初始化」和「赋值」都被提升了。





### new

`new` 操作符可以帮助我们构建出一个实例，并且绑定上 `this`。

 ![img](E:\codee\VuePress-blog\docs\cate\images\v2-7508e2814e9362256c11af76b1db646d_720w.jpg)



只要你在士兵前面使用 new 关键字，那么可以少做四件事情：

1. 不用创建临时对象，因为 new 会帮你做（**你使用「this」就可以访问到临时对象**）；
2. 不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；
3. 不用 return 临时对象，因为 new 会帮你做；
4. 不要给原型想名字了，因为 new 指定名字为 prototype。



**new 的作用，就是省那么几行代码。（也就是所谓的语法糖）**



new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：

```text
士兵.prototype = {
  constructor: 士兵
}
```

如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了



#### 手写

简单版

```js
function Otaku (name, age) {
    this.name = name;
    this.age = age;

    this.habit = 'Games';
}

Otaku.prototype.strength = 60;

Otaku.prototype.sayYourName = function () {
    console.log('I am ' + this.name);
}

function objectFactory() {
    // 创建新对象
    var obj = new Object();
    // 获取构造函数
    Constructor = [].shift.call(arguments);
    // 继承原型链
    obj.__proto__ = Constructor.prototype;
    // 改变this指向
    Constructor.apply(obj, arguments);
    return obj;
};

var person = objectFactory(Otaku, 'Kevin', '18')

console.log(person.name) // Kevin
console.log(person.habit) // Games
console.log(person.strength) // 60

person.sayYourName(); // I am Kevin
```





有返回值的

```
// 第二版的代码
function objectFactory() {

    Constructor = [].shift.call(arguments);
    
    // 原始版
    var obj = new Object();
    obj.__proto__ = Constructor.prototype;
    // es5
    var obj = Object.create(Constructor.prototype)

    var ret = Constructor.apply(obj, arguments);

    return ret instanceof Object ? ret : obj;

};
```





### call、apply、bind

#### 介绍

call、apply都是为了改变函数中的this指向的

区别就是接受参数的方式不太一样

call一个个传，apply传数组



```js
func.call(this, arg1, arg2);
func.apply(this, [arg1, arg2])
```



bind

MDN的解释是：`bind()`方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 `bind()`方法的第一个参数作为 `this`，传入 `bind()` 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。

bind只能绑定一次





#### 手写

##### call

```js
Function.prototype.myCall = function (context) {
  // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。
  if(typeof this !== 'function'){
    throw new TypeError(this + ' is not a function');
  }
  const ctx = context || window;
  ctx.fn = this;
  const args = [...arguments].slice(1)
  const result = ctx.fn(...args);
  delete context.fn;
  return result;
}

const obj = {
  a: 1
}

function a () {
  console.log(this.a)
}

a()

a.myCall(obj)
```



https://segmentfault.com/a/1190000017206223



##### apply

```js
Function.prototype.myApply = function (context, args || []) {
  // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。
  if(typeof this !== 'function'){
    throw new TypeError(this + ' is not a function');
  }
  const ctx = context || window;
  ctx.fn = this;
  const result = ctx.fn(...args);
  delete context.fn;
  return result;
}
```







##### bind

```js
Function.prototype.bind2 = function (context) {

    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    // 空函数隔了一层，改bind后的原型不会影响到bind对象的原型
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```



### 原型

JavaScript 中的对象从其他对象继承功能特性。



函数上有个prototype属性，指向其的原型

实例化该函数得到的实例对象，有个`__proto__`属性，指向的就是其构造函数的原型。

这么做使得实例对象能获取到构造函数上的属性、方法。

这样一个个串起来就组成了原型链



### class

`class` 只是原型链的语法糖，与其它语言中的类不是同一样东西。

 

ES6 中：

```
class Person {
    constructor(name) {
        this.name = name;
    }

    sayHello() {
        return 'hello, I am ' + this.name;
    }
}

var kevin = new Person('Kevin');
kevin.sayHello(); // hello, I am Kevin
```

对应到 ES5 中就是:

```
function Person(name) {
    this.name = name;
}

Person.prototype.sayHello = function () {
    return 'hello, I am ' + this.name;
};

var kevin = new Person('Kevin');
kevin.sayHello(); // hello, I am Kevin
```



### 继承

#### 原型链继承

引用对象是共用的



#### 组合继承

调用了两遍parent



#### 寄生组合式继承

原型链不用new去继承，而是通过间接创建个函数去继承，从而隔离原型链的共用，也只调用了一次父函数









### 模块化

为了方便复用、分类等架构需求，需对代码进行拆分、模块化



#### window

不同文件直接往window上挂变量



#### IIFE

浏览器环境下，在全局作用域声明的变量都是全局变量。全局变量存在命名冲突、占用内存无法被回收、代码可读性低等诸多问题。

这时，IIFE（匿名立即执行函数）出现了：

```javascript
;(function () {
  ...
}());
```

IIFE的出现，使全局变量的声明数量得到了有效的控制。





#### 命名空间

依靠`window`对象承载数据的方式是“不可靠”的，如`window.config.api`，如果`window.config`不存在，则`window.config.api`就会报错，所以为了避免这样的错误，代码里会大量的充斥`var api = window.config && window.config.api;`这样的代码。



这时，`namespace`登场了，简约版本的`namespace`函数的实现（只为演示，不要用于生产）：



```javascript
function namespace(tpl, value) {
  return tpl.split('.').reduce((pre, curr, i) => {
    return (pre[curr] = i === tpl.split('.').length - 1
      ? (value || pre[curr])	// 不传value就是取值
      : (pre[curr] || {}))
  }, window);
}
```





#### AMD/CMD

##### RequireJS

AMD 是一种异步模块规范，RequireJS 是 AMD 规范的实现。

```bash
# 项目目录:
├─ js                # js文件夹
│  ├─ ...
│  └─ require.js     # RequireJS 的 JS 库
└─  ...
// config.js
define(function() {
  var api = 'https://github.com/ronffy';
  var config = {
    api: api,
  };
  return config;
});
// utils.js
define(['./config'], function(config) {
  var utils = {
    request() {
      console.log(config.api);
    }
  };
  return utils;
});
// main.js
require(['./utils'], function(utils) {
  utils.request();
});
<!-- index.html  -->
<!-- ...省略其他 -->
<body>

  <script data-main="./js/main" src="./js/require.js"></script>
</body>
</html>
```

特别说明：
先有 RequireJS，后有 AMD 规范，随着 RequireJS 的推广和普及，AMD 规范才被创建出来。





##### CMD

CMD 和 AMD 一样，都是 JS 的模块化规范，也主要应用于浏览器端。
AMD 是 RequireJS 在的推广和普及过程中被创造出来。
CMD 是 SeaJS 在的推广和普及过程中被创造出来。

二者的的主要区别是 CMD 推崇依赖就近，AMD 推崇依赖前置：



#### CommonJS

AMD、CMD 主要用于浏览器端，随着 node 诞生，服务器端的模块规范 CommonJS 被创建出来。

```javascript
// config.js
var api = 'https://github.com/ronffy';
var config = {
  api: api,
};
module.exports = config;
// utils.js
var config = require('./config');
var utils = {
  request() {
    console.log(config.api);
  }
};
module.exports = utils;
// main.js
var utils = require('./utils');
utils.request();
console.log(global.api)
```







##### exports`和`module.exports

module.exports：

导出的module是个对象，包含exports属性，引入时会自动取module.exports中的值



模块初始化时，`exports`和`module.exports`指向同一块内存，`exports`被重新赋值后，就切断了跟原内存地址的关系。

所以，`exports`要这样使用：

```javascript
// a.js
exports.s = 'i am ronffy';

// b.js
var a = require('./a.js');
console.log(a.s); // i am ronffy
```





#### UMD

```javascript
!function (root, factory) {
  if (typeof exports === 'object' && typeof module === 'object') {
    // CommonJS2
    module.exports = factory()
    // define.amd 用来判断项目是否应用 require.js。
    // 更多 define.amd 介绍，请[查看文档](https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property-)
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory)
  } else if (typeof exports === 'object') {
    // CommonJS
    exports.myLibName = factory()
  } else {
    // 全局变量
    root.myLibName = factory()
  }
}(window, function () {
  // 模块初始化要执行的代码
});
```



就是做环境判断



#### ES6 module

##### 导出

方式1

```javascript
export const prefix = 'https://github.com';
export const api = `${prefix}/ronffy`;
```

方式2

```javascript
const prefix = 'https://github.com';
const api = `${prefix}/ronffy`;
export {
  prefix,
  api,
}
```

方式3（默认导出）

```javascript
// foo.js
export default function foo() {}

// 等同于：
function foo() {}
export {
  foo as default
}
```





##### 导入

方式1

```javascript
import { api } from './config.js';

// or
// 配合`import`使用的`as`关键字用来为导入的接口重命名。
import { api as myApi } from './config.js';
```

方式2（整体导入）

```javascript
import * as config from './config.js';
const api = config.api;
```

将 config.js 模块导出的所有接口都挂载在`config`对象上。

方式3（默认导出的导入）

```javascript
// foo.js
export const conut = 0;
export default function myFoo() {}
// index.js
// 默认导入的接口此处刻意命名为cusFoo，旨在说明该命名可完全自定义。
import cusFoo, { count } from './foo.js';

// 等同于：
import { default as cusFoo, count } from './foo.js';
```

`export default`导出的接口，可以使用`import name from 'module'`导入。这种方式，使导入默认接口很便捷。

方式4（整体加载）

```javascript
import './config.js';
```

方式5（动态加载模块）

```javascript
// 报错
if (/* ... */) {
  import { api } from './config.js'; 
}

// 报错
function foo() {
  import { api } from './config.js'; 
}

// 报错
const modulePath = './utils' + '/api.js';
import modulePath;
```

使用`import()`实现按需加载：

```javascript
function foo() {
  import('./config.js')
    .then(({ api }) => {

    });
}

const modulePath = './utils' + '/api.js';
import(modulePath);
```

特别说明：
该功能的提议目前处于 TC39 流程的第4阶段。更多说明，请查看[TC39/proposal-dynamic-import](https://link.segmentfault.com/?enc=Ww9tckF9x9hIijp7NwcIoQ%3D%3D.AXklgTS5MaMTHWgsqAeEhGrlgKPx5E8Ci%2BzvzgR15JNsMtKOipIQ%2FRILHmCJCj7R)。







#### CommonJS 和 ES6 module

CommonJS 和 AMD 是运行时加载，在运行时确定模块的依赖关系。
ES6 module 是在编译时（`import()`是运行时加载）处理模块依赖关系。



commonjs是值的拷贝，改变导出的值不会引起原值的改变

esm是值的引用，会影响原值



都有做缓存



`CommonJS` 可以在运行时使用变量进行 `require`, 例如 `require(path.join('xxxx', 'xxx.js'))`，而静态 `import` 语法（还有动态 import，返回 Promise）不行，因为 `ES6` 模块会先解析所有模块再执行代码。



`require` 会将完整的 `exports` 对象引入，`import` 可以只 `import` 部分必要的内容，这也是为什么使用 `Tree Shaking` 时必须使用 ES6 模块 的写法。import 另一个模块没有 `export` 的变量，在代码执行前就会报错，而 CommonJS 是在模块运行时才报错。







#### 为什么babel将esm转为commonjs





#### __esModule 是什么？干嘛用的？

使用转换工具处理 `ES6` 模块的时候，常看到打包之后出现 `__esModule` 属性，字面意思就是将其标记为 `ES6 Module`。这个变量存在的作用是为了方便在引用模块的时候加以处理。

例如 `ES6` 模块中的 `export default` 在转化成 CommonJS 时会被挂载到 `exports['default']` 上，当运行 `require('./a.js')` 时 是不能直接读取到 default 上的值的，为了和 ES6 中 `import a from './a.js'`的行为一致，会基于 `__esModule` 判断处理。

```go
// a.jsexport default 1; // main.jsimport a from './a'; console.log(a);
```

转化后

```go
// a.jsObject.defineProperty(exports, "__esModule", {  value: true});exports.default = 1; // main.js'use strict'; var _a = require('./a'); var _a2 = _interopRequireDefault(_a); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } console.log(_a2.default);
```

a 模块 `export defualt` 会被转换成 `exports.default = 1`;，这也是平时前端项目开发中使用 `require` 为什么还常常需要 .`default` 才能取到目标值的原因。

接着当运行 `import a from './a.js'` 时，`es module` 预期的是返回 export 的内容。工具会将代码转换为 `_interopRequireDefault` 包裹，在里面判断是否为 esModule，是的话直接返回，如果是 `commonjs` 模块的话则包裹一层 `{default: obj}`，最后获取 `a` 的值时，也会被装换成 `_a1.default`。







### Promise

promise 有 3 个状态，分别是 pending, fulfilled 和 rejected。

在 pending 状态，promise 可以切换到 fulfilled 或 rejected。

在 fulfilled 状态，不能迁移到其它状态，必须有个不可变的 value。

在 rejected 状态，不能迁移到其它状态，必须有个不可变的 reason。



#### 简单版

```js
function MyPromise (fn) {
  // 回调函数集
  this.cbs = [];

  // 传入的fn执行回调
  const resolve = (value) => {
    setTimeout(() => this.cbs.forEach((cb) => cb(value)));
  }

  // 调用fn
  fn(resolve)
}

MyPromise.prototype.then = function (onResolve) {
  // 为了能链式调用then
  return new MyPromise((resolve) => {
    this.cbs.push((value) => {
      const res = onResolve(value)
      // 解决then里返回的是promise
      if (res instanceof MyPromise) {
        res.then(resolve)
      } else {
        resolve(res)
      }
    })
  })
}
```



```js
new MyPromise((resolve) => {
  setTimeout(() => {
    resolve(1);
  }, 500);
})
  .then((res) => {
    console.log(res);
    return new MyPromise((resolve) => {
      setTimeout(() => {
        resolve(2);
      }, 1000);
    });
  })
  .then(console.log);
```





#### 完整版

```js
// 判断变量否为function
const isFunction = variable => typeof variable === 'function'
// 定义Promise的三种状态常量
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
  constructor (handle) {
    if (!isFunction(handle)) {
      throw new Error('MyPromise must accept a function as a parameter')
    }
    // 添加状态
    this._status = PENDING
    // 添加状态
    this._value = undefined
    // 添加成功回调函数队列
    this._fulfilledQueues = []
    // 添加失败回调函数队列
    this._rejectedQueues = []
    // 执行handle
    try {
      handle(this._resolve.bind(this), this._reject.bind(this))
    } catch (err) {
      this._reject(err)
    }
  }

  // 添加resovle时执行的函数
  _resolve (val) {
    const run = () => {
      if (this._status !== PENDING) return
      // 依次执行成功队列中的函数，并清空队列
      const runFulfilled = (value) => {
        this._fulfilledQueues.forEach((item) => {
          item(value)
        })
        this._fulfilledQueues = []
        // let cb
        // while (cb = this._fulfilledQueues.shift()) {
        //   cb(value)
        // }
      }
      // 依次执行失败队列中的函数，并清空队列
      const runRejected = (error) => {
        this._rejectedQueues.forEach((item) => {
          item(error)
        })
        this._rejectedQueues = []
        // let cb
        // while (cb = this._rejectedQueues.shift()) {
        //   cb(error)
        // }
      }
      /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
        当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
      */
      if (val instanceof MyPromise) {
        val.then(value => {
          this._value = value
          this._status = FULFILLED
          runFulfilled(value)
        }, err => {
          this._value = err
          this._status = REJECTED
          runRejected(err)
        })
      } else {
        this._value = val
        this._status = FULFILLED
        runFulfilled(val)
      }
    }
    // 为了支持同步的Promise，这里采用异步调用
    setTimeout(run, 0)
  }

  // 添加reject时执行的函数
  _reject (err) {
    if (this._status !== PENDING) return
    // 依次执行失败队列中的函数，并清空队列
    const run = () => {
      this._status = REJECTED
      this._value = err
      this._rejectedQueues.forEach((item) => {
        item(err)
      })
      this._rejectedQueues = []
      // let cb
      // while (cb = this._rejectedQueues.shift()) {
      //   cb(err)
      // }
    }
    // 为了支持同步的Promise，这里采用异步调用
    setTimeout(run, 0)
  }

  // 添加then方法
  then (onFulfilled, onRejected) {
    const {_value, _status} = this
    // 返回一个新的Promise对象
    return new MyPromise((onFulfilledNext, onRejectedNext) => {
      // 封装一个成功时执行的函数
      let fulfilled = value => {
        try {
          if (!isFunction(onFulfilled)) {
            onFulfilledNext(value)
          } else {
            let res = onFulfilled(value)
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext)
            } else {
              // 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
              onFulfilledNext(res)
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的P  romise对象的状态为失败
          onRejectedNext(err)
        }
      }
      // 封装一个失败时执行的函数
      let rejected = error => {
        try {
          if (!isFunction(onRejected)) {
            onRejectedNext(error)
          } else {
            let res = onRejected(error)
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext)
            } else {
              // 否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
              onFulfilledNext(res)
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的Promise对象的状态为失败
          onRejectedNext(err)
        }
      }
      switch (_status) {
        // 当状态为pending时，将then方法回调函数加入执行队列等待执行
        case PENDING:
          this._fulfilledQueues.push(fulfilled)
          this._rejectedQueues.push(rejected)
          break
        // 当状态已经改变时，立即执行对应的回调函数
        case FULFILLED:
          fulfilled(_value)
          break
        case REJECTED:
          rejected(_value)
          break
      }
    })
  }

  // 添加catch方法
  catch (onRejected) {
    return this.then(undefined, onRejected)
  }

  // 添加静态resolve方法
  static resolve (value) {
    // 如果参数是MyPromise实例，直接返回这个实例
    if (value instanceof MyPromise) return value
    return new MyPromise(resolve => resolve(value))
  }

  // 添加静态reject方法
  static reject (value) {
    return new MyPromise((resolve, reject) => reject(value))
  }

  // 添加静态all方法
  static all (list) {
    return new MyPromise((resolve, reject) => {
      /**
       * 返回值的集合
       */
      let values = []
      let count = 0
      for (let [i, p] of list.entries()) {
        // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
        this.resolve(p).then(res => {
          values[i] = res
          count++
          // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
          if (count === list.length) resolve(values)
        }, err => {
          // 有一个被rejected时返回的MyPromise状态就变成rejected
          reject(err)
        })
      }
    })
  }

  // 添加静态race方法
  static race (list) {
    return new MyPromise((resolve, reject) => {
      for (let p of list) {
        // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
        this.resolve(p).then(res => {
          resolve(res)
        }, err => {
          reject(err)
        })
      }
    })
  }

  finally (cb) {
    return this.then(
      value => MyPromise.resolve(cb()).then(() => value),
      reason => MyPromise.resolve(cb()).then(() => {
        throw reason
      })
    )
  }
}

export default MyPromise

```





### 迭代器与生成器

生成器是一种可以用来控制迭代器（iterator）的函数，它可以随时暂停，并可以在任意时候恢复。



```js
function * generatorForLoop(num) {
  for (let i = 0; i < num; i += 1) {
    yield console.log(i);
  }
}

const genForLoop = generatorForLoop(5);

genForLoop.next(); // 首先 console.log - 0
genForLoop.next(); // 1
genForLoop.next(); // 2
genForLoop.next(); // 3
genForLoop.next(); // 4

```







### async await

async函数是generator函数的语法糖



#### 手写

就是用promise包一下，然后每个yield结束后递归调用下一步，结束时resolve。

```js
/**
 * async的执行原理
 * 其实就是自动执行generator函数
 * 暂时不考虑genertor的编译步骤（更复杂）
 */

const getData = () =>
  new Promise(resolve => setTimeout(() => resolve("data"), 1000))

// 这样的一个async函数 应该再1秒后打印data
async function test() {
  const data = await getData()

  console.log(data)
  return data
}

// async函数会被编译成generator函数 (babel会编译成更本质的形态，这里我们直接用generator)
function* testG() {
  // await被编译成了yield
  const data = yield getData()
  console.log('data: ', data);
  const data2 = yield getData()
  console.log('data2: ', data2);
  return data + '123'
}

function asyncToGenerator(generatorFunc) {
  return function() {
    const gen = generatorFunc.apply(this, arguments)

    return new Promise((resolve, reject) => {
      function step(key, arg) {
        let generatorResult
        try {
          generatorResult = gen[key](arg)
        } catch (error) {
          return reject(error)
        }

        const { value, done } = generatorResult

        if (done) {
          return resolve(value)
        } else {
          return Promise.resolve(value).then(
            function onResolve(val) {
              step("next", val)
            },
            function onReject(err) {
              step("throw", err)
            },
          )
        }
      }
      step("next")
    })
  }
}

const testGAsync = asyncToGenerator(testG)
testGAsync().then(result => {
  console.log(result)
})
```









### 事件循环

#### js单线程







































