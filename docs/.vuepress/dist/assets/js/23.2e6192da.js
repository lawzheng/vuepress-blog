(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{403:function(t,e,n){"use strict";n.r(e);var l=n(44),a=Object(l.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"背景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),n("p",[t._v("交换机胖模式，因机器内存大小限制，不能随意引用外部插件。为了解决表格内容过长时的显示问题，于是自己实现手动拖动改变列宽功能，提升用户体验。")]),t._v(" "),n("h2",{attrs:{id:"实现逻辑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现逻辑"}},[t._v("#")]),t._v(" 实现逻辑")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("首先在原有表格组件中增加配置选项，用来开启表格的列拖动功能，默认false。")])]),t._v(" "),n("li",[n("p",[t._v("表格配置项中的每列的宽度不能带单位，带单位会导致无法拖动（依据旧组件架构，只能出此下策）。通过改变表头的宽度，使tBody部分自动跟随。")])]),t._v(" "),n("li",[n("p",[t._v("在获取接口数据后，直接生成固定在顶部的表头，这个表头原本是在第一次滚动时生成的，这个css结构决定了后面的一系列妥协。")])])]),t._v(" "),n("p",[t._v("生成表头后为其绑定鼠标事件。")]),t._v(" "),n("p",[t._v("鼠标下落事件：")]),t._v(" "),n("p",[t._v("记录拖动元素的位置，宽度信息。特别提醒，位置需要用clientX获取，用x获取的话在IE下可能会不准（因为event.x如果是在relative定位的盒子中，是已该盒子进行计算的，而不是屏幕）。")]),t._v(" "),n("p",[t._v("鼠标移动事件：")]),t._v(" "),n("p",[t._v("保证列宽不为负的情况下，记录拖动后的宽度，并赋给当前元素。为了兼容ie9，需要同时赋值最小宽度。")]),t._v(" "),n("p",[t._v("因表头为了固定在顶部，旧的架构使用了另外一个table，给我们的改动宽度带来了很大的困难。这里在拖动后获取实际内容表格每列的宽度，再赋值给表头，来实现每列的宽度自动适应。")]),t._v(" "),n("p",[t._v("鼠标上事件：")]),t._v(" "),n("p",[t._v("清除数据，延迟100ms后再执行一次调整表头位置，防止快速拖动时导致的错位。")]),t._v(" "),n("h2",{attrs:{id:"源码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#源码"}},[t._v("#")]),t._v(" 源码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n * 设置列宽可拖动\n * @param $tab\n * @private\n */\n_setColConfig: function($tab) {\n    var me = this;\n    if (this.options.changeColWidth) {\n        var mainTable = this.$el[0].children[0]\n        var table = $tab || mainTable\n        var tTD; //用来存储当前更改宽度的Table Cell,避免快速移动鼠标的问题\n        for (j = 0; j < table.rows[0].cells.length; j++) {\n            table.rows[0].cells[j].onmousedown = function () {\n                //记录单元格\n                tTD = this;\n                if (event.offsetX > tTD.offsetWidth - 10) {\n                    tTD.mouseDown = true;\n                    tTD.oldX = event.clientX;\n                    tTD.oldWidth = tTD.offsetWidth;\n                }\n            };\n            table.rows[0].cells[j].onmousemove = function () {\n                //更改鼠标样式\n                if (event.offsetX > this.offsetWidth - 10)\n                    this.style.cursor = 'col-resize';\n                else\n                    this.style.cursor = 'default';\n                //取出暂存的Table Cell\n                if (tTD == undefined) tTD = this;\n                //调整宽度\n                if (tTD.mouseDown != null && tTD.mouseDown == true) {\n                    tTD.style.cursor = 'default';\n                    if (tTD.oldWidth + (event.clientX - tTD.oldX) > 0) {\n                        var tTdWidth = tTD.oldWidth + (event.clientX - tTD.oldX) + '';\n                        tTD.width = tTdWidth\n                    }\n                    //调整列宽\n                    tTD.style.width = tTdWidth + 'px';\n                    tTD.style.minWidth = tTdWidth + 'px';\n                    tTD.style.cursor = 'col-resize';\n                    //调整该列中的每个Cell\n                    table = tTD;\n                    while (table.tagName != 'TABLE') table = table.parentElement;\n                    for (j = 0; j < table.rows.length; j++) {\n                        // 改变固定表头的宽度\n                        table.rows[j].cells[tTD.cellIndex].width = tTdWidth;\n                        table.rows[j].cells[tTD.cellIndex].style.width = tTdWidth + 'px';\n                        // 改变主内容表格的宽度\n                        if ($tab) {\n                            mainTable.rows[j].cells[tTD.cellIndex].width = tTdWidth;\n                            mainTable.rows[j].cells[tTD.cellIndex].style.width = tTdWidth + 'px';\n                            mainTable.rows[j].cells[tTD.cellIndex].style.minWidth = tTdWidth + 'px';\n                        }\n                    }\n                    if ($tab) {\n                        me._setFixTableHeadWidth(table, mainTable)\n                    }\n                }\n            };\n            table.rows[0].cells[j].onmouseup = function () {\n                //结束宽度调整\n                if (tTD == undefined) tTD = this;\n                tTD.mouseDown = false;\n                tTD.style.cursor = 'default';\n                // 结束时再执行一次，防止错位\n                if ($tab) {\n                    setTimeout(function() {\n                        me._setFixTableHeadWidth(table, mainTable)\n                    }, 100)\n                }\n            };\n        }\n    }\n},\n/**\n * 根据主内容表格的宽度来设置固定的表头的宽度\n * @param table\n * @param mainTable\n * @private\n */\n_setFixTableHeadWidth: function (table, mainTable) {\n    for (var k = 0; k < mainTable.rows[0].cells.length; k++) {\n        var width = mainTable.rows[0].cells[k].offsetWidth + 'px'\n        table.rows[0].cells[k].style.width = width\n        table.rows[0].cells[k].style.minWidth = width\n    }\n},\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);