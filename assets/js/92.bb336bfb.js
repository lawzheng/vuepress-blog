(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{499:function(t,a,s){"use strict";s.r(a);var r=s(38),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"终端图标统一处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#终端图标统一处理"}},[t._v("#")]),t._v(" 终端图标统一处理")]),t._v(" "),a("h2",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("p",[t._v("由于历史原因，在前端代码中存在好几套终端图标的写法：")]),t._v(" "),a("ol",[a("li",[t._v("通过图标名生成class去匹配精灵图的坐标")]),t._v(" "),a("li",[t._v("通过类型id去匹配class")]),t._v(" "),a("li",[t._v("通过字段判断是否自定义的图片")]),t._v(" "),a("li",[t._v("通过类型id匹配svg图片（最新写法）")])]),t._v(" "),a("p",[t._v("正好最近的项目终端识别中，需要升级终端类型库，于是将控制器中的所有图标写法都统一起来，方便后续维护。")]),t._v(" "),a("h2",{attrs:{id:"实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),a("p",[t._v("由于控制器中存在vue和ext两套框架，需要分别处理对应的页面。")]),t._v(" "),a("h3",{attrs:{id:"vue页面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue页面"}},[t._v("#")]),t._v(" vue页面")]),t._v(" "),a("p",[t._v("vue页面中已封装好了一套基于id去匹配svg的组件，只需要改造一下即可。")]),t._v(" "),a("h4",{attrs:{id:"缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),a("p",[t._v("由于新增的很多终端类型没有专门设计图标，需要使用其父类的图标。")]),t._v(" "),a("p",[t._v("所以通过请求终端类型的数据并缓存成map，方便子类型查不到专属图标时去找父类型的。")]),t._v(" "),a("h4",{attrs:{id:"获取"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取"}},[t._v("#")]),t._v(" 获取")]),t._v(" "),a("p",[t._v("之前的获取类型是非响应式的，加上远程数据后就不适用了。")]),t._v(" "),a("p",[t._v("通过在远程数据中提供一个加载状态，起到加载完后触发重新查找的效果。")]),t._v(" "),a("h3",{attrs:{id:"ext页面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ext页面"}},[t._v("#")]),t._v(" ext页面")]),t._v(" "),a("h4",{attrs:{id:"渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染"}},[t._v("#")]),t._v(" 渲染")]),t._v(" "),a("p",[a("strong",[t._v("模板中渲染")])]),t._v(" "),a("p",[t._v("观察ext的页面基本是在表格或者渲染模板中使用到了图标，且生成的dom结构也是基本一致的。")]),t._v(" "),a("p",[t._v("这里提供一个hook，通过h函数渲染vue的图标组件，再生成一个随机不重复的id，添加到渲染模板中：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token template-string"}},[a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('<span class="dev-icon-ext-span" id="')]),a("span",{pre:!0,attrs:{class:"token interpolation"}},[a("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("renderId"),a("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('" title="')]),a("span",{pre:!0,attrs:{class:"token interpolation"}},[a("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("title "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("??")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),a("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"></span>')]),a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v("\n")])])]),a("p",[t._v("ext在render时使用返回的模板进行渲染，在一个定时器周期后，调用vue的render函数将生成的VNode挂载到指定id中，就实现了图标的渲染。")]),t._v(" "),a("p",[t._v("注：")]),t._v(" "),a("p",[t._v("之所以用定时器去实现，是因为IxIcon是通过promise异步渲染的，h后是拿不到完整dom。")]),t._v(" "),a("p",[a("strong",[t._v("提供dom渲染")])]),t._v(" "),a("p",[t._v("在端口面板中，原来的实现是在端口的dom上添加class去实现。")]),t._v(" "),a("p",[t._v("这种存在dom的更好实现，只需要render到对应dom上即可。")]),t._v(" "),a("h4",{attrs:{id:"磨平接口差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#磨平接口差异"}},[t._v("#")]),t._v(" 磨平接口差异")]),t._v(" "),a("p",[t._v("由于历史原因，存在好几套图标的写法。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("icon名匹配")]),t._v(" "),a("p",[t._v("这种通过icon转id再去匹配svg")])]),t._v(" "),a("li",[a("p",[t._v("自定义图片")]),t._v(" "),a("p",[t._v("如果存在自定义的图片，则去匹配出图片路径，通过img去渲染")])]),t._v(" "),a("li",[a("p",[t._v("其它的则通过id去匹配svg")])])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("通过以上实现，解决了之前多套写法不统一的问题，后续只需维护一份id对应图片的映射关系即可。")])])}),[],!1,null,null,null);a.default=e.exports}}]);