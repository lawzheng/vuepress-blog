# 知识回顾



## html

### 语义化

html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。在没有引入样式 CCS 样式的时候也能以一种可以分辨出来大致表示内容的文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

```
<article> 独立的区域
<aside>	侧边栏
<details> 可以展开收起的区域
<figcaption>与其相关联的图片的说明/标题
<figure> 图片
<footer>	
<header>
<main>
<mark> 突出的文本
<nav>
<section>  一节，一般来说会有包含一个标题。
<summary> like detail
<time> 时间
```





## css

- [一文梳理 CSS 必会知识点](https://juejin.cn/post/6854573212337078285)



### CSS引入

#### 有哪些引入方式？通过link和@import引入有什么区别？（* ）

- **CSS引入方式有4种** 内联、内嵌、外链、导入
- **外链 link** 除了可以加载css之外,还可以定义rss、rel等属性，没有兼容性问题，支持使用javascript改变样式
- **导入@import** 是css提供的，只能用于加载css，不支持通过javascript修改样式
- 页面被加载的时候，link会被同时加载，而@import则需等到页面加载完后再加载，可能出现无样式网页







### 盒模型

两种 宽度计算方式不同

默认content-box



#### 获取和设置盒模型的宽高

- 第一种：

dom.style.width/height

这种方法只能获取使用内联样式的元素的宽和高。

- 第二种：

dom.currentStyle.width/height

这种方法获取的是浏览器渲染以后的元素的宽和高，无论是用何种方式引入的css样式都可以，但只有IE浏览器支持这种写法。

- 第三种：

window.getComputedStyle(dom).width/height

这种方法获取的也是浏览器渲染以后的元素的宽和高，但这种写法兼容性更好一些。

- 第四种：

dom.getBoundingClientRect().width/height

这种方法经常使用的场所是，计算一个元素的绝对位置（相对于视窗左上角），它能拿到元素的left、top、width、height 4个属性。



#### border颜色

没设置时取color的



#### 去除inline-block元素间间距的N种方法

1. 元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就木有了。考虑到代码可读性，显然连成一行的写法是不可取的，我们可以：

```html
<div class="space">
    <a href="##">
    惆怅</a><a href="##">
    淡定</a><a href="##">
    热血</a>
</div>
```

或者是：

```html
<div class="space">
    <a href="##">惆怅</a
    ><a href="##">淡定</a
    ><a href="##">热血</a>
</div>
```

或者是借助HTML注释：

```html
<div class="space">
    <a href="##">惆怅</a><!--
    --><a href="##">淡定</a><!--
    --><a href="##">热血</a>
</div>
```

2. 使用margin负值

   margin负值的大小与上下文的字体和文字大小相关，其中，间距对应大小值可以参见我之前“基于display:inline-block的列表布局”一文part 6的统计表格：
   ![图片](https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq6Jcrf1F9amot5V85cLUcmhdSjN0CUZSRQ8epOPezvhCYpmf7AjPSZ6zqibY0N0c2ibdVT74BsV5seA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   例如，对于12像素大小的上下文，Arial字体的`margin`负值为`-3`像素，Tahoma和Verdana就是`-4`像素，而Geneva为`-6`像素。

   由于外部环境的不确定性，以及最后一个元素多出的父margin值等问题，这个方法不适合大规模使用。

   

3. 不写结尾标签

   有兼容性

   ```html
   <div class="space">
       <a href="##">惆怅
       <a href="##">淡定
       <a href="##">热血
   </div>
   ```

   

4. 父元素使用font-size:0

   chrome现已取消最小12px的限制

   

5. letter-spacing、word-spacing

6. flex等改变盒布局方式



#### 行内元素可以设置padding，margin吗？

宽高不起作用

padding左右可以，上下不占实际位置，但是类似于定位，上下也有多出来



#### padding 百分比

根据**父元素**的**宽度**计算

是父元素，不是自己



为什么不根据自己的宽度呢？而要根据父元素？

1. 如果自己没宽度怎么算
2. 算了自己的，自己不又变大了，死循环





### 选择器

1. *匹配所有

   不建议直接使用，影响性能，每个元素都会带上。

   看了reset.css，是用具体标签做初始化的。

2. #id

   不常用，一般都是用class，id用来js获取元素

3. .class

4. li a

   后代选择器，不建议层级过多

5. 单个元素选择器

6. X:visited and X:link

   ```css
   a:link { color: red; }
   a:visted { color: purple; }
   ```

   我们使用`:link`伪类来定义所有还没点击的链接。

   另外还有`:visited`伪类可以让我们给*曾经*点击过或者*访问过*的链接添加样式。

7. x + y

   后面的第一个元素

8. x > y

   直接的子代

9. x ~ y

   后面的元素

10. X[title]、 X[href="foo"]

    属性选择器，

11. X:checked

12. X:after

13. X:hover

14. X:not(selector)

    过滤某个

15. X:nth-child(n)

    从1开始

16. X:nth-last-child(n)



### 优先级

| 选择器               | 权重值 |
| :------------------- | :----- |
| !important标识       | 10000  |
| 行内样式             | 1000   |
| id选择器             | 100    |
| 类、伪类、属性选择器 | 10     |
| 标签选择器           | 1      |
| 通配符 *             | 0      |



问题：已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。

>  <img src="1.jpg" style="width:480px!important;">  

期初看到这段代码一下子就想到这都 `!important` 了还有办法限制它的宽度？真的是被无知限制了想象力。

这里提供几种方法实现修改宽度：



1、使用max-width

虽然使用了 `important` ，但是也只是添加到了 `width` 属性上面，并不影响 max-width 。所以这里设置了 max-width 即可生效。

```javascript
img {
  max-width: 300px;
}
```

2、使用 transform:scale

```javascript
img {
  transform: scaleX(0.625);
}
```

3、使用 zoom

这个和CSS3的缩放是一样的效果

```javascript
img {
  zoom: 0.625：
}
```

4、使用 js

这个和CSS3的缩放是一样的效果

```javascript
document.getElementsByTagName("img")[0].setAttribute("style","width:300px!important;")
```

5、使用弹性盒模型

这个和CSS3的缩放是一样的效果

```javascript
img {
  box-sizing: border-box;
  padding: 0 90px;
}
```

6、使用animation

```javascript
img {
  animation: width 0s forwards;
}
@keyframes width {
  from {
    width: 300px;
  }
  to {
    width: 300px;
  }
}
```





### flex

#### flex-direction

方向 row column



#### flex-wrap

换行方式 倒着换行等



`flex-direction` 和 `flex-wrap` 可以简写成 **`flex-flow`** 。 `flex-flow` 使用时可以只显式设置一个值，也可以显式设置两个值：

- `flex-flow` 只显式设置一个值，并且该值和 `<flex-direction>` 相匹配时， `flex-wrap` 会取值 `initial`
- `flex-flow` 只显式设置一个值，并且该值和 `<flex-wrap>`相匹配时， `flex-direction` 会取值 `initial`
- `flex-flow` 显式设置两个值时， `flex-direction` 和 `flow-wrap` 没有先后顺序之分，即可 `flex-flow: column wrap` 和 `flex-flow: wrap column` 等同



#### justify-content

主轴方向的对齐方式

![img](E:\codee\VuePress-blog\docs\webArchitect\images\ad858777d27a4e34ae5c3bda0f88fe63~tplv-k3u1fbpfcp-watermark.awebp)

`space-between` 会让第一个Flex项目的盒子起始边缘与Flex容器主轴起点相稳合，最后一个Flex项目的盒子结束边缘与Flex容器主轴终点相稳合，其它相邻Flex项目之间间距相等。当Flex容器中只有一个Flex项目时，其表现行为和 `flex-start` 等同

`space-around` 会让第一个Flex项目的盒子起始边缘与Flex容器主轴起点间距和最后一个Flex项目的盒子结束边缘与Flex容器主轴终点间距相等，并且等于其他相邻两个Flex项目之间间距的一半。当Flex容器中只有一个Flex项目时，其表现行为和 `center` 等同

`space-evenly` 会让第一个Flex项目的盒子起始边缘与Flex容器主轴起点间距和最后一个Flex项目的盒子结束边缘与Flex容器主轴终点间距相等，并且等于其他相邻两个Flex项目之间间距。当Flex容器中只有一个Flex项目时，其表现行为和 `center` 等同



#### align-items

侧轴方向对齐

![img](E:\codee\VuePress-blog\docs\webArchitect\images\191245d917d2496baefa79f9a471039d~tplv-k3u1fbpfcp-watermark.awebp)



### grid

比flex强大很多

网格系统



#### 基础用法

```html
<div class="wrapper">
  <div class="one item">One</div>
  <div class="two item">Two</div>
  <div class="three item">Three</div>
  <div class="four item">Four</div>
  <div class="five item">Five</div>
  <div class="six item">Six</div>
</div>
```



```css
.wrapper {
  margin: 60px;
  /* 声明一个容器 */
  display: grid;
  /*  声明列的宽度  */
  grid-template-columns: repeat(3, 200px);
  /*  声明行间距和列间距  */
  grid-gap: 20px 50px;
  /*  声明行的高度  */
  grid-template-rows: 100px 200px;
}
.one {
  background: #19CAAD;
}
.two { 
  background: #8CC7B5;
}
.three {
  background: #D1BA74;
}
.four {
  background: #BEE7E9;
}
.five {
  background: #E6CEAC;
}
.six {
  background: #ECAD9E;
}
.item {
  text-align: center;
  font-size: 200%;
  color: #fff;
}
```



![img](E:\codee\VuePress-blog\docs\webArchitect\images\173895918bfd94e9~tplv-t2oaga2asx-watermark.awebp)

通过`grid-template-columns` 和 `grid-template-rows`来控制行和列





#### **fr 关键字**

`Grid` 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。`fr` 单位代表网格容器中可用空间的一等份。`grid-template-columns: 200px 1fr 2fr` 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。代码以及效果如下图所示：

```
.wrapper-3 {
  display: grid;
  grid-template-columns: 200px 1fr 2fr;
  grid-gap: 5px;
  grid-auto-rows: 50px;
}
```



![image](E:\codee\VuePress-blog\docs\webArchitect\images\17389591ccc256d1~tplv-t2oaga2asx-watermark.awebp)



#### **minmax() 函数**

我们有时候想给网格元素一个最小和最大的尺寸

`grid-template-columns: 1fr 1fr minmax(300px, 2fr)` 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍



#### 位置处理

justify-items 、align-items

```
start | end | center | stretch;
```



看起来是改变内部元素（文字等）的左中右。而不是该元素的位置



justify-content 、align-content

```
start | end | center | stretch | space-around | space-between | space-evenly;
```

这就跟flex的差不多，只是名字有点区别





#### 兼容性

![img](E:\codee\VuePress-blog\docs\webArchitect\images\17389592fa541366~tplv-t2oaga2asx-watermark.awebp)

兼容不太好，用的也不多

适合瀑布流的布局



### 1px border

1、用图片、不方便

2、动态改变viewport的缩放比例

```
	
<meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">

```

3、伪类 + transform

原理是把原先元素的 border 去掉，然后利用 `:before` 或者 `:after` 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位

- 单条 border

```css
.hairlines li{
    position: relative;
    border:none;
}
.hairlines li:after{
    content: '';
    position: absolute;
    left: 0;
    background: #000;
    width: 100%;
    height: 1px;
    -webkit-transform: scaleY(0.5);
            transform: scaleY(0.5);
    -webkit-transform-origin: 0 0;
            transform-origin: 0 0;
}

```

- 四条 border

```css
.hairlines li{
    position: relative;
    margin-bottom: 20px;
    border:none;
}
.hairlines li:after{
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid #000;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
    width: 200%;
    height: 200%;
    -webkit-transform: scale(0.5);
    transform: scale(0.5);
    -webkit-transform-origin: left top;
    transform-origin: left top;
}
```

样式使用的时候，也要结合 JS 代码，判断是否 Retina 屏

```js
if(window.devicePixelRatio && devicePixelRatio >= 2){
    document.querySelector('ul').className = 'hairlines';
}
```

可以支持圆角，唯一的一点小缺陷是 ` 用不了。







改viewport会影响整个页面，老项目还是得用伪类解决。





## js



### 数据类型

#### 类型分类

分两大类，共八种类型。

基本类型： Number、String、Null、Undefined、Boolean、Symbol、BigInt

引用类型： Object



#### 基本类型、引用类型区别

- 基本类型
  1. 存放在栈内存
  2. 数据的比较是值的比较
- 引用类型
  1. 栈内存存放指向堆内存中的地址。真实数据存储在堆内存中
  2. 数据的比较是引用地址的比较



#### undefined与null的区别

**是否相等**

```js
null == undefined   true
null === undefined  false
```

undefined值是派生自null值

与JavaScript的历史有关。1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示"无"的值。
根据C语言的传统，null被设计成可以自动转为0。

```
Number(null)0
Number(undefined)NaN
```

但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。
首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示"无"的值最好不是对象。
其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。
因此，Brendan Eich又设计了一个undefined。



**用法**

null表示"没有对象"，即该处不应该有值。典型用法是：

（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。

undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：

（1）变量被声明了，但没有赋值时，就等于undefined。

（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

（3）对象没有赋值的属性，该属性的值为undefined。

（4）函数没有返回值时，默认返回undefined。



#### symbol有什么用

1. 做唯一不重复的键值

2. 不用new，不是构造函数。像函数一样调用

3. 做私有属性。不会被`for in`、`Object.keys`、`JSON.stringify`之类的获取到。

   只能通过`Object.getOwnPropertySymbols`获取



#### BigInt

JS中，按照[IEEE 754-2008](https://link.segmentfault.com/?enc=QC1p6JNViWax%2FcbIhHoO8g%3D%3D.GhLuybeOKy%2BdMNDXHyRYIYXEfJUMdNJ0MupiDrnCGlLpiW6VtZHK3FIS%2BjBUosI30FI83x1ajQze0F2RvDDkXA%3D%3D)标准的定义，所有数字都以[双精度64位浮点](https://link.segmentfault.com/?enc=C2nXxdz5Qo6ZiLkR47AyOA%3D%3D.I%2BUAEefgZOCqdLiV1LzUXSUXpsj4riMZ%2BZcPqU2wsUOXYZGGMLoX7KQhwfzamwyctIMkqoisw68TnDxb8fBXmeWbY28VdPHKRzfF8XDJGck%3D)格式表示。

在此标准下，无法精确表示的非常大的整数将自动四舍五入。确切地说，JS 中的`Number`类型只能安全地表示`-9007199254740991 (-(2^53-1))` 和`9007199254740991(2^53-1)`之间的整数，任何超出此范围的整数值都可能失去精度。

```1c
console.log(9999999999999999);    // → 10000000000000000
```

该整数大于JS Number 类型所能表示的最大整数，因此，它被四舍五入的。意外四舍五入会损害程序的可靠性和安全性。这是另一个例子：

```abnf
// 注意最后一位的数字
9007199254740992 === 9007199254740993;    // → true
```

JS 提供`Number.MAX_SAFE_INTEGER`常量来表示 最大安全整数，`Number.MIN_SAFE_INTEGER`常量表示最小安全整数：

```javascript
const minInt = Number.MIN_SAFE_INTEGER;

console.log(minInt);         // → -9007199254740991

console.log(minInt - 5);     // → -9007199254740996

// notice how this outputs the same value as above
console.log(minInt - 4);     // → -9007199254740996
```



`BigInt`是一种新的数据类型，用于当整数值大于`Number`数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

重要的是要记住，不能使用`Number`和`BigInt`操作数的混合执行算术运算，需要通过显式转换其中的一种类型。 此外，出于兼容性原因，不允许在`BigInt`上使用一元加号（`+`）运算符。



详细：

https://segmentfault.com/a/1190000019912017



#### 没有BigInt之前怎么办

使用[JSBI](https://link.segmentfault.com/?enc=gH1STo%2FdvFDcCkyFmg6PbQ%3D%3D.RUwB0MWvYb1s3fNNuTKJOZhveeq5KymhWftBn2M6ldb7oHACnHbWtgsJJjDcGX7U)库，它是`BigInt`提案的纯JS实现。

这个库提供了一个与原生`BigInt`行为完全相同的API。下面是如何使用JSBI：

```javascript
import JSBI from './jsbi.mjs';

const b1 = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
const b2 = JSBI.BigInt('10');

const result = JSBI.add(b1, b2);

console.log(String(result));    // → '9007199254741001'
```

使用`JSBI`的一个优点是，一旦浏览器支持，就不需要重写代码。 相反，可以使用`babel`插件自动将JSBI代码编译为原生 `BigInt`代码。



**手写**

```js
let a = "9007199254740991";
let b = "1234567899999999999";

function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength , 0);//"0009007199254740991"
   b = b.padStart(maxLength , 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i=maxLength-1 ; i>=0 ; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t/10);
      sum = t%10 + sum;
   }
   if(f == 1){
      sum = "1" + sum;
   }
   return sum;
}
```



### 类型判断

#### typeof

可以判断基本类型，除了null

| Type                                                         | Result                                                       |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [Undefined](https://developer.mozilla.org/en-US/docs/Glossary/undefined) | `"undefined"`                                                |
| [Null](https://developer.mozilla.org/en-US/docs/Glossary/Null) | `"object"` (see [below](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null)) |
| [Boolean](https://developer.mozilla.org/en-US/docs/Glossary/Boolean) | `"boolean"`                                                  |
| [Number](https://developer.mozilla.org/en-US/docs/Glossary/Number) | `"number"`                                                   |
| [BigInt](https://developer.mozilla.org/en-US/docs/Glossary/BigInt) (new in ECMAScript 2020) | `"bigint"`                                                   |
| [String](https://developer.mozilla.org/en-US/docs/Glossary/String) | `"string"`                                                   |
| [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) (new in ECMAScript 2015) | `"symbol"`                                                   |
| [Function](https://developer.mozilla.org/en-US/docs/Glossary/Function) object (implements [[Call]] in ECMA-262 terms) | `"function"`                                                 |
| Any other object                                             | `"object"`                                                   |



##### typeof null是object

JS类型值是存在32 BIT 单元里,32位有1-3位表示TYPE TAG,其它位表示真实值
而表示object的标记位正好是低三位都是0
000: object. The data is a reference to an object.

而js 里的Null 是机器码NULL空指针, (0x00 is most platforms).所以空指针引用 加上 对象标记还是0,最终体现的类型还是object.

在ECMA6中, 曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了. 理由是历史遗留代码太多, 不想得罪人, 不如继续将错就错当和事老, 参考 [harmony:typeof_null [ES Wiki\]](https://link.zhihu.com/?target=http%3A//wiki.ecmascript.org/doku.php%3Fid%3Dharmony%3atypeof_null)



##### typeof function

function本质上也是一个对象，但是function对象与普通对象相比，其内部有一个[[Call]]方法，用来表示这个对象是可调用的，typeof操作符在判断Object时，如果内部实现了[[Call]]方法,就返回function。
附上typeof操作符返回判断图：



#### instanceof

`instanceof` 运算符用来检测 `constructor.prototype `是否存在于参数 `object` 的原型链上。

原型链是可以被修改的，所以这是不安全的判断方法。



##### 一些容易出错的点
```js
var simpleStr = "This is a simple string"; 
var myString  = new String();
var newStr    = new String("String created with constructor");
var myDate    = new Date();
var myObj     = {};
var myNonObj  = Object.create(null);

simpleStr instanceof String; // 返回 false, simpleStr并不是对象
myString  instanceof String; // 返回 true
newStr    instanceof String; // 返回 true
myString  instanceof Object; // 返回 true

myObj instanceof Object;    // 返回 true, 尽管原型没有定义
({})  instanceof Object;    // 返回 true, 同上
myNonObj instanceof Object; // 返回 false, 一种创建非 Object 实例的对象的方法

myString instanceof Date; // 返回 false

myDate instanceof Date;     // 返回 true
myDate instanceof Object;   // 返回 true
myDate instanceof String;   // 返回 false
```



##### 手写instanceof
核心: 原型链的向上查找。

```js
function myInstanceof (left, right) {
    // 基本数据类型直接返回false
    if (typeof left !== 'object' || left === null) return false
    // getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left)
    while (true) {
        // 查找到尽头，还没找到
        if (proto == null) return false
        // 找到相同的原型对象
        if (proto == right.prototype) return true
        proto = Object.getPrototypeOf(proto)
    }
}
```



#### Object.prototype.toString

`toString()` 方法返回一个表示该对象的字符串

如果此方法在自定义对象中未被覆盖，`toString()` 返回 "[object *type*]"，其中 `type` 是对象的类型



```
var toString = Object.prototype.toString;

toString.call(new Date); // [object Date]
toString.call(new String); // [object String]
toString.call(Math); // [object Math]

//Since JavaScript 1.8.5
toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]
```



**封装**

```js
var class2type = {};

// 生成class2type映射
"Boolean Number String Function Array Date RegExp Object Error".split(" ").map(function(item, index) {
    class2type["[object " + item + "]"] = item.toLowerCase();
})

function type(obj) {
    // 一箭双雕
    if (obj == null) {
        return obj + "";
    }
    return typeof obj === "object" || typeof obj === "function" ?
        class2type[Object.prototype.toString.call(obj)] || "object" :
        typeof obj;
}
```





#### Array.isArray

```
// 下面的函数调用都返回 true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
Array.isArray(new Array('a', 'b', 'c', 'd'))
// 鲜为人知的事实：其实 Array.prototype 也是一个数组。
Array.isArray(Array.prototype);
```

**Polyfill**

假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。

```
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```



#### 详细

- [JavaScript 专题之类型判断(上)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F28)
- [JavaScript 专题之类型判断(下)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F30)



### 类型转换

- [JavaScript 深入之头疼的类型转换(上)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F159)
- [JavaScript 深入之头疼的类型转换(下)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F164)



### this

#### 什么是`this`

1. this是JavaScript的关键字之一。它是 对象 自动生成的一个内部对象，只能在 对象 内部使用。随着函数使用场合的不同，this的值会发生变化。
2. **this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时**。（比较多人误解的地方）（它非常语义化，this在英文中的含义就是 **这，这个** ，但这其实起到了一定的误导作用，因为this并不是一成不变的，并不一定一直指向当前 **这个**）



#### `this` 绑定规则

1. 谁调用的就是谁，没给就是window
2. call、apply、bind主动改的
3. new



#### this绑定优先级

```haxe
new 绑定 > 显示绑定 > 隐式绑定 > 默认绑定
```



#### 手写

##### call

```js
Function.prototype.myCall = function (context) {
  // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。
  if(typeof this !== 'function'){
    throw new TypeError(this + ' is not a function');
  }
  const ctx = context || window;
  ctx.fn = this;
  const args = [...arguments].slice(1)
  const result = ctx.fn(...args);
  delete context.fn;
  return result;
}

const obj = {
  a: 1
}

function a () {
  console.log(this.a)
}

a()

a.myCall(obj)
```



https://segmentfault.com/a/1190000017206223



##### apply

```js
Function.prototype.myCall = function (context, args || []) {
  // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。
  if(typeof this !== 'function'){
    throw new TypeError(this + ' is not a function');
  }
  const ctx = context || window;
  ctx.fn = this;
  const result = ctx.fn(...args);
  delete context.fn;
  return result;
}
```







##### bind





##### new









#### 总结

1. 如果函数被`new` 修饰

   ```haxe
      this绑定的是新创建的对象，例:var bar = new foo();  函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar , 这样的绑定方式叫 new绑定 .
   ```

2. 如果函数是使用`call,apply,bind`来调用的

   ```gradle
      this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj , 这样的绑定方式叫 显性绑定 .
   ```

3. 如果函数是在某个 上下文对象 下被调用

   ```kotlin
      this绑定的是那个上下文对象，例 : var obj = { foo : foo };    obj.foo();  foo 中的 this 就是 obj . 这样的绑定方式叫 隐性绑定 .
   ```

4. 如果都不是，即使用默认绑定

   ```nim
      例:function foo(){...} foo() ,foo 中的 this 就是 window.(严格模式下默认绑定到undefined).
      这样的绑定方式叫 默认绑定 .
   ```



#### 参考文档

https://segmentfault.com/a/1190000011194676



### 闭包

聊作用域。

返回函数引用了父级的变量，导致无法释放。

牵扯到垃圾回收机制。



### 作用域

作用域是指程序中定义变量的区域，该位置决定了变量的生命周期，也就是变量和函数的可访问范围。

JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。

函数的作用域是在函数调用的时候才决定的。



### 作用域链

当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this



当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。



函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！





### 变量提升

变量提升（Hoisting）可以将变量和函数在编译阶段放入内存，从而在执行阶段时在声明前使用



在声明变量 `a` 之前打印变量，控制台输出的结果是 `undefined`，而不是预期中的报错 `Uncaught ReferenceError: a is not defined`。这就是**变量提升**。



实际上，JS 并不会移动代码，变量提升和函数提升并不是真正意义上的“提升”，而是解释执行 JS 代码过程所带来的“特性”。



- 对于变量声明如 `var a = 3`，会为变量分配内存并初始化为 `undefined`，赋值语句在生成机器码阶段真正执行代码的时候才进行。
- 对于函数声明如 `function sayHello() { console.log('Hello there!') }`，会在内存里创建函数对象，并且直接初始化为该函数对象。



应当注意的是，函数声明的处理优先级要高于变量声明（意味着函数会“提升”到更靠前的位置），同名函数优先了



#### 匿名函数声明

基于变量声明和函数声明之间的区别，在实际应用中，使用**匿名函数**的方式执行声明更不容易产生奇怪的 Bug：

```
sayHi() // Uncaught TypeError: sayHi is not a functionconsole.log(sayHi) // undefinedvar sayHi = function() {    console.log('Hi there!')}sayHi() // Hi there!
```

使用匿名函数声明时，`sayHi` 声明发生变量提升，但赋值为 `undefined`，因此执行 `sayHi()` 时会报错 `Uncaught TypeError: sayHi is not a function`。随后执行完赋值语句后，才成为一个可以执行的函数变量。



#### 为什么要变量提升和函数提升

由于第一批 JS 虚拟机编译器上代码的设计失误，导致了变量在声明之前就被赋予了 `undefined` 的初始值，产生了变量提升



函数提升，为了解决相互引用





1. let 的「创建」过程被提升了，但是初始化没有提升。
2. var 的「创建」和「初始化」都被提升了。
3. function 的「创建」「初始化」和「赋值」都被提升了。





### new















