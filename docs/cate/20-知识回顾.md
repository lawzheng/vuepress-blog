# 知识回顾



## html

### 语义化

html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。在没有引入样式 CCS 样式的时候也能以一种可以分辨出来大致表示内容的文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

```
<article> 独立的区域
<aside>	侧边栏
<details> 可以展开收起的区域
<figcaption>与其相关联的图片的说明/标题
<figure> 图片
<footer>	
<header>
<main>
<mark> 突出的文本
<nav>
<section>  一节，一般来说会有包含一个标题。
<summary> like detail
<time> 时间
```





## css

- [一文梳理 CSS 必会知识点](https://juejin.cn/post/6854573212337078285)





### 盒模型

两种 宽度计算方式不同

默认content-box



#### 获取和设置盒模型的宽高

- 第一种：

dom.style.width/height

这种方法只能获取使用内联样式的元素的宽和高。

- 第二种：

dom.currentStyle.width/height

这种方法获取的是浏览器渲染以后的元素的宽和高，无论是用何种方式引入的css样式都可以，但只有IE浏览器支持这种写法。

- 第三种：

window.getComputedStyle(dom).width/height

这种方法获取的也是浏览器渲染以后的元素的宽和高，但这种写法兼容性更好一些。

- 第四种：

dom.getBoundingClientRect().width/height

这种方法经常使用的场所是，计算一个元素的绝对位置（相对于视窗左上角），它能拿到元素的left、top、width、height 4个属性。



#### border颜色

没设置时取color的



#### 去除inline-block元素间间距的N种方法

1. 元素间留白间距出现的原因就是标签段之间的空格，因此，去掉HTML中的空格，自然间距就木有了。考虑到代码可读性，显然连成一行的写法是不可取的，我们可以：

```html
<div class="space">
    <a href="##">
    惆怅</a><a href="##">
    淡定</a><a href="##">
    热血</a>
</div>
```

或者是：

```html
<div class="space">
    <a href="##">惆怅</a
    ><a href="##">淡定</a
    ><a href="##">热血</a>
</div>
```

或者是借助HTML注释：

```html
<div class="space">
    <a href="##">惆怅</a><!--
    --><a href="##">淡定</a><!--
    --><a href="##">热血</a>
</div>
```

2. 使用margin负值

   margin负值的大小与上下文的字体和文字大小相关，其中，间距对应大小值可以参见我之前“基于display:inline-block的列表布局”一文part 6的统计表格：
   ![图片](https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq6Jcrf1F9amot5V85cLUcmhdSjN0CUZSRQ8epOPezvhCYpmf7AjPSZ6zqibY0N0c2ibdVT74BsV5seA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   例如，对于12像素大小的上下文，Arial字体的`margin`负值为`-3`像素，Tahoma和Verdana就是`-4`像素，而Geneva为`-6`像素。

   由于外部环境的不确定性，以及最后一个元素多出的父margin值等问题，这个方法不适合大规模使用。

   

3. 不写结尾标签

   有兼容性

   ```html
   <div class="space">
       <a href="##">惆怅
       <a href="##">淡定
       <a href="##">热血
   </div>
   ```

   

4. 父元素使用font-size:0

   chrome现已取消最小12px的限制

   

5. letter-spacing、word-spacing

6. flex等改变盒布局方式



#### 行内元素可以设置padding，margin吗？

宽高不起作用

padding左右可以，上下不占实际位置，但是类似于定位，上下也有多出来



#### padding 百分比

根据**父元素**的**宽度**计算

是父元素，不是自己



为什么不根据自己的宽度呢？而要根据父元素？

1. 如果自己没宽度怎么算
2. 算了自己的，自己不又变大了，死循环





## js



### 数据类型

#### 类型分类

分两大类，共八种类型。

基本类型： Number、String、Null、Undefined、Boolean、Symbol、BigInt

引用类型： Object



#### 基本类型、引用类型区别

- 基本类型
  1. 存放在栈内存
  2. 数据的比较是值的比较
- 引用类型
  1. 栈内存存放指向堆内存中的地址。真实数据存储在堆内存中
  2. 数据的比较是引用地址的比较



#### undefined与null的区别

**是否相等**

```js
null == undefined   true
null === undefined  false
```

undefined值是派生自null值

与JavaScript的历史有关。1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示"无"的值。
根据C语言的传统，null被设计成可以自动转为0。

```
Number(null)0
Number(undefined)NaN
```

但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。
首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示"无"的值最好不是对象。
其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。
因此，Brendan Eich又设计了一个undefined。



**用法**

null表示"没有对象"，即该处不应该有值。典型用法是：

（1） 作为函数的参数，表示该函数的参数不是对象。

（2） 作为对象原型链的终点。

undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：

（1）变量被声明了，但没有赋值时，就等于undefined。

（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。

（3）对象没有赋值的属性，该属性的值为undefined。

（4）函数没有返回值时，默认返回undefined。



#### symbol有什么用

1. 做唯一不重复的键值

2. 不用new，不是构造函数。像函数一样调用

3. 做私有属性。不会被`for in`、`Object.keys`、`JSON.stringify`之类的获取到。

   只能通过`Object.getOwnPropertySymbols`获取



#### BigInt

JS中，按照[IEEE 754-2008](https://link.segmentfault.com/?enc=QC1p6JNViWax%2FcbIhHoO8g%3D%3D.GhLuybeOKy%2BdMNDXHyRYIYXEfJUMdNJ0MupiDrnCGlLpiW6VtZHK3FIS%2BjBUosI30FI83x1ajQze0F2RvDDkXA%3D%3D)标准的定义，所有数字都以[双精度64位浮点](https://link.segmentfault.com/?enc=C2nXxdz5Qo6ZiLkR47AyOA%3D%3D.I%2BUAEefgZOCqdLiV1LzUXSUXpsj4riMZ%2BZcPqU2wsUOXYZGGMLoX7KQhwfzamwyctIMkqoisw68TnDxb8fBXmeWbY28VdPHKRzfF8XDJGck%3D)格式表示。

在此标准下，无法精确表示的非常大的整数将自动四舍五入。确切地说，JS 中的`Number`类型只能安全地表示`-9007199254740991 (-(2^53-1))` 和`9007199254740991(2^53-1)`之间的整数，任何超出此范围的整数值都可能失去精度。

```1c
console.log(9999999999999999);    // → 10000000000000000
```

该整数大于JS Number 类型所能表示的最大整数，因此，它被四舍五入的。意外四舍五入会损害程序的可靠性和安全性。这是另一个例子：

```abnf
// 注意最后一位的数字
9007199254740992 === 9007199254740993;    // → true
```

JS 提供`Number.MAX_SAFE_INTEGER`常量来表示 最大安全整数，`Number.MIN_SAFE_INTEGER`常量表示最小安全整数：

```javascript
const minInt = Number.MIN_SAFE_INTEGER;

console.log(minInt);         // → -9007199254740991

console.log(minInt - 5);     // → -9007199254740996

// notice how this outputs the same value as above
console.log(minInt - 4);     // → -9007199254740996
```



`BigInt`是一种新的数据类型，用于当整数值大于`Number`数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

重要的是要记住，不能使用`Number`和`BigInt`操作数的混合执行算术运算，需要通过显式转换其中的一种类型。 此外，出于兼容性原因，不允许在`BigInt`上使用一元加号（`+`）运算符。



详细：

https://segmentfault.com/a/1190000019912017



#### 没有BigInt之前怎么办

使用[JSBI](https://link.segmentfault.com/?enc=gH1STo%2FdvFDcCkyFmg6PbQ%3D%3D.RUwB0MWvYb1s3fNNuTKJOZhveeq5KymhWftBn2M6ldb7oHACnHbWtgsJJjDcGX7U)库，它是`BigInt`提案的纯JS实现。

这个库提供了一个与原生`BigInt`行为完全相同的API。下面是如何使用JSBI：

```javascript
import JSBI from './jsbi.mjs';

const b1 = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
const b2 = JSBI.BigInt('10');

const result = JSBI.add(b1, b2);

console.log(String(result));    // → '9007199254741001'
```

使用`JSBI`的一个优点是，一旦浏览器支持，就不需要重写代码。 相反，可以使用`babel`插件自动将JSBI代码编译为原生 `BigInt`代码。



**手写**

```js
let a = "9007199254740991";
let b = "1234567899999999999";

function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength , 0);//"0009007199254740991"
   b = b.padStart(maxLength , 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i=maxLength-1 ; i>=0 ; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t/10);
      sum = t%10 + sum;
   }
   if(f == 1){
      sum = "1" + sum;
   }
   return sum;
}
```



### 类型判断

#### typeof

可以判断基本类型，除了null

| Type                                                         | Result                                                       |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [Undefined](https://developer.mozilla.org/en-US/docs/Glossary/undefined) | `"undefined"`                                                |
| [Null](https://developer.mozilla.org/en-US/docs/Glossary/Null) | `"object"` (see [below](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null)) |
| [Boolean](https://developer.mozilla.org/en-US/docs/Glossary/Boolean) | `"boolean"`                                                  |
| [Number](https://developer.mozilla.org/en-US/docs/Glossary/Number) | `"number"`                                                   |
| [BigInt](https://developer.mozilla.org/en-US/docs/Glossary/BigInt) (new in ECMAScript 2020) | `"bigint"`                                                   |
| [String](https://developer.mozilla.org/en-US/docs/Glossary/String) | `"string"`                                                   |
| [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) (new in ECMAScript 2015) | `"symbol"`                                                   |
| [Function](https://developer.mozilla.org/en-US/docs/Glossary/Function) object (implements [[Call]] in ECMA-262 terms) | `"function"`                                                 |
| Any other object                                             | `"object"`                                                   |



##### typeof null是object

JS类型值是存在32 BIT 单元里,32位有1-3位表示TYPE TAG,其它位表示真实值
而表示object的标记位正好是低三位都是0
000: object. The data is a reference to an object.

而js 里的Null 是机器码NULL空指针, (0x00 is most platforms).所以空指针引用 加上 对象标记还是0,最终体现的类型还是object.

在ECMA6中, 曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了. 理由是历史遗留代码太多, 不想得罪人, 不如继续将错就错当和事老, 参考 [harmony:typeof_null [ES Wiki\]](https://link.zhihu.com/?target=http%3A//wiki.ecmascript.org/doku.php%3Fid%3Dharmony%3atypeof_null)



##### typeof function

function本质上也是一个对象，但是function对象与普通对象相比，其内部有一个[[Call]]方法，用来表示这个对象是可调用的，typeof操作符在判断Object时，如果内部实现了[[Call]]方法,就返回function。
附上typeof操作符返回判断图：



#### instanceof

`instanceof` 运算符用来检测 `constructor.prototype `是否存在于参数 `object` 的原型链上。

原型链是可以被修改的，所以这是不安全的判断方法。



##### 一些容易出错的点
```js
var simpleStr = "This is a simple string"; 
var myString  = new String();
var newStr    = new String("String created with constructor");
var myDate    = new Date();
var myObj     = {};
var myNonObj  = Object.create(null);

simpleStr instanceof String; // 返回 false, simpleStr并不是对象
myString  instanceof String; // 返回 true
newStr    instanceof String; // 返回 true
myString  instanceof Object; // 返回 true

myObj instanceof Object;    // 返回 true, 尽管原型没有定义
({})  instanceof Object;    // 返回 true, 同上
myNonObj instanceof Object; // 返回 false, 一种创建非 Object 实例的对象的方法

myString instanceof Date; // 返回 false

myDate instanceof Date;     // 返回 true
myDate instanceof Object;   // 返回 true
myDate instanceof String;   // 返回 false
```



##### 手写instanceof
核心: 原型链的向上查找。

```js
function myInstanceof (left, right) {
    // 基本数据类型直接返回false
    if (typeof left !== 'object' || left === null) return false
    // getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left)
    while (true) {
        // 查找到尽头，还没找到
        if (proto == null) return false
        // 找到相同的原型对象
        if (proto == right.prototype) return true
        proto = Object.getPrototypeOf(proto)
    }
}
```



#### Object.prototype.toString

`toString()` 方法返回一个表示该对象的字符串

如果此方法在自定义对象中未被覆盖，`toString()` 返回 "[object *type*]"，其中 `type` 是对象的类型



```
var toString = Object.prototype.toString;

toString.call(new Date); // [object Date]
toString.call(new String); // [object String]
toString.call(Math); // [object Math]

//Since JavaScript 1.8.5
toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]
```



**封装**

```js
var class2type = {};

// 生成class2type映射
"Boolean Number String Function Array Date RegExp Object Error".split(" ").map(function(item, index) {
    class2type["[object " + item + "]"] = item.toLowerCase();
})

function type(obj) {
    // 一箭双雕
    if (obj == null) {
        return obj + "";
    }
    return typeof obj === "object" || typeof obj === "function" ?
        class2type[Object.prototype.toString.call(obj)] || "object" :
        typeof obj;
}
```





#### Array.isArray

```
// 下面的函数调用都返回 true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
Array.isArray(new Array('a', 'b', 'c', 'd'))
// 鲜为人知的事实：其实 Array.prototype 也是一个数组。
Array.isArray(Array.prototype);
```

**Polyfill**

假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。

```
if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```



#### 详细

- [JavaScript 专题之类型判断(上)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F28)
- [JavaScript 专题之类型判断(下)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F30)



### 类型转换

- [JavaScript 深入之头疼的类型转换(上)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F159)
- [JavaScript 深入之头疼的类型转换(下)](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F164)



### this

#### 什么是`this`

1. this是JavaScript的关键字之一。它是 对象 自动生成的一个内部对象，只能在 对象 内部使用。随着函数使用场合的不同，this的值会发生变化。
2. **this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时**。（比较多人误解的地方）（它非常语义化，this在英文中的含义就是 **这，这个** ，但这其实起到了一定的误导作用，因为this并不是一成不变的，并不一定一直指向当前 **这个**）



#### `this` 绑定规则

1. 谁调用的就是谁，没给就是window
2. call、apply、bind主动改的
3. new



#### this绑定优先级

```haxe
new 绑定 > 显示绑定 > 隐式绑定 > 默认绑定
```



#### 手写

##### call

```js
Function.prototype.myCall = function (context) {
  // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。
  if(typeof this !== 'function'){
    throw new TypeError(this + ' is not a function');
  }
  const ctx = context || window;
  ctx.fn = this;
  const args = [...arguments].slice(1)
  const result = ctx.fn(...args);
  delete context.fn;
  return result;
}

const obj = {
  a: 1
}

function a () {
  console.log(this.a)
}

a()

a.myCall(obj)
```



https://segmentfault.com/a/1190000017206223



##### apply

```js
Function.prototype.myCall = function (context, args || []) {
  // 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。
  if(typeof this !== 'function'){
    throw new TypeError(this + ' is not a function');
  }
  const ctx = context || window;
  ctx.fn = this;
  const result = ctx.fn(...args);
  delete context.fn;
  return result;
}
```







##### bind





##### new









#### 总结

1. 如果函数被`new` 修饰

   ```haxe
      this绑定的是新创建的对象，例:var bar = new foo();  函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar , 这样的绑定方式叫 new绑定 .
   ```

2. 如果函数是使用`call,apply,bind`来调用的

   ```gradle
      this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj , 这样的绑定方式叫 显性绑定 .
   ```

3. 如果函数是在某个 上下文对象 下被调用

   ```kotlin
      this绑定的是那个上下文对象，例 : var obj = { foo : foo };    obj.foo();  foo 中的 this 就是 obj . 这样的绑定方式叫 隐性绑定 .
   ```

4. 如果都不是，即使用默认绑定

   ```nim
      例:function foo(){...} foo() ,foo 中的 this 就是 window.(严格模式下默认绑定到undefined).
      这样的绑定方式叫 默认绑定 .
   ```



#### 参考文档

https://segmentfault.com/a/1190000011194676



### 闭包

聊作用域。

返回函数引用了父级的变量，导致无法释放。

牵扯到垃圾回收机制。



### 作用域

